### UX‑аудит онбординга «Услуги / товары» (BusinessProfileEditor)

#### ISSUE‑01: Кнопка «Помощь AI» молчит, когда активен Telegram‑hint

- **Наблюдение**  
  - Сейчас `handleServicesAiHelpClick` сразу делает `return`, если `showTelegramHint === true`  
    (`app/office/businesses/[id]/profile/BusinessProfileEditor.tsx`, `handleServicesAiHelpClick`).  
  - В этом случае при клике по «Помощь AI» визуально **ничего не происходит**: нет ни скролла, ни подсказки, ни disable‑состояния.
- **Почему**  
  - Логика приоритета: пока висит Telegram‑подсказка, онбординг услуг не запускается, чтобы не «перегружать» пользователя.  
  - Но пользователю это неочевидно — выглядит как «кнопка не работает».
- **Предложенная правка (минимальная)**  
  - Вместо глухого `return` при `showTelegramHint`:
    - проскроллить к блоку Telegram‑подсказки (`showTelegramHint && ...` блок под кнопкой «Сохранить изменения»),  
      используя `scrollIntoView({ behavior: 'smooth', block: 'center' })`;
    - на 1–1.5 секунды подсветить Telegram‑hint (например, добавить временную рамку/тень через state `highlightTelegramHint`).
  - Это чётко даёт понять: «Сначала разберись с Telegram, потом вернёмся к услугам».
- **Риск / побочный эффект**  
  - Низкий: меняется только реакция на клик по «Помощь AI» в одном конкретном состоянии (активен Telegram‑hint).  
  - Скролл и подсветка не затрагивают бизнес‑логику и не меняют данные.

---

#### ISSUE‑02: Возможные гонки при клике «Помощь AI» во время форматирования (step='formatting')

- **Наблюдение**  
  - Пока идёт форматирование (`servicesOnboardingStep === 'formatting'`, `servicesAiLoading === true`),  
    пользователь всё ещё может нажать «Помощь AI».  
  - В `handleServicesAiHelpClick` нет проверки `servicesAiLoading`/`servicesOnboardingStep`, только `showTelegramHint`.
- **Почему это проблема**  
  - Можно попасть в ситуацию, когда:
    1. step `'formatting'` → идёт запрос `/api/ai`;
    2. пользователь жмёт «Помощь AI» → step насильно переводится в `'asking'`;
    3. затем приходит ответ AI, форматирование завершает step `'done'` и инициирует скролл к результатам.  
  - Визуально это выглядит как «прыгающий» UI и может сбивать с толку.
- **Предложенная правка (минимальная)**  
  - В `handleServicesAiHelpClick` добавить ранний выход, если AI занят:
    - `if (servicesAiLoading || servicesOnboardingStep === 'formatting') return;`  
      (либо дополнительно показать небольшой inline‑текст/disabled‑состояние кнопки).
  - Параллельно можно добавить `disabled={servicesAiLoading || servicesOnboardingStep === 'formatting'}` на кнопку «Помощь AI».
- **Риск / побочный эффект**  
  - Низкий: пользователь просто не сможет запустить второй онбординг, пока первый не завершён.  
  - Бизнес‑данные и форматирование не меняются.

---

#### ISSUE‑03: Debug‑маркер и console.log‑ы в проде

- **Наблюдение**  
  - В начале файла объявлен `const SERVICES_ONBOARDING_BUILD_MARKER = 'SERVICES_ONBOARDING_V1'` и есть `useEffect`, который его «использует».  
  - В `handleServicesOnboardingStart` и `handleServicesOnboardingSubmit` остались `console.log('SERVICES_ONBOARDING_V1: ...')`.  
  - Это было нужно для диагностики потока/бандла, но в проде такие логи и побочные эффекты — шум.
- **Почему это проблема**  
  - Лишние `console.log` в продакшене:
    - засоряют консоль владельца/клиента;
    - могут быть частично вырезаны bundler’ом, но не гарантированно;
    - не несут пользы конечному пользователю.
  - Build‑маркер через `useEffect` постоянно гоняет микроскопический side‑effect на клиенте.
- **Предложенная правка (минимальная)**  
  - После завершения отладки:
    - убрать `console.log` из хендлеров онбординга (оставив только UI и сетевые вызовы);
    - либо удалить `SERVICES_ONBOARDING_BUILD_MARKER` и связанный `useEffect` вообще,  
      либо обернуть их в `if (process.env.NODE_ENV !== 'production')` с комментарием, зачем это.
  - Для дальнейшей проверки попадания в bundle достаточно data‑атрибутов (`data-services-onboarding="v1"` и т.п.).
- **Риск / побочный эффект**  
  - Низкий: это чисто debug‑инструменты, не влияющие на отображение или сохранение данных.  
  - Удаление/ослабление не затронет поведение UI.

---

#### ISSUE‑04: Потенциальные нюансы скролла в контексте sticky‑правой колонки

- **Наблюдение**  
  - Правая колонка (`position: sticky; top: 2rem`) содержит кнопку «Сохранить» и блок диалога.  
  - Мы вызываем `scrollIntoView({ behavior: 'smooth', block: 'center' })` на внутреннем `div` диалога (`servicesOnboardingRef`) и  
    `scrollIntoView({ behavior: 'smooth', block: 'center' })` на первом input услуг.  
  - На очень маленьких экранах / при сильном зуме sticky‑контейнер может занимать большую часть высоты.
- **Потенциальный эффект**  
  - В ряде браузеров `block: 'center'` при `position: sticky` может не давать визуального эффекта «центрования»,  
    а просто дотягивать контейнер до ближайшей видимой точки.  
  - На практике это не ломает UX, но может создавать ощущение, что скролл "не совсем туда".
- **Предложенная правка (опциональная, низкий приоритет)**  
  - Для правой колонки оставить `block: 'center'` (это всё же лучшее приближение ожидаемого поведения).  
  - Для скролла к первому input можно рассмотреть `block: 'start'`, если окажется, что на мобиле центрирование выглядит странно.  
  - Это стоит трогать только после живого просмотра поведения на нескольких устройствах.
- **Риск / побочный эффект**  
  - Низкий, но изменение поведения скролла потенциально затронет мышечную память тех, кто уже привык к текущему поведению.

---

#### ISSUE‑05: Мёртвый код `callServicesAi` (не влияет на UX, но путает читаемость)

- **Наблюдение**  
  - В файле осталась функция `callServicesAi(mode: 'suggest' | 'improve')`, полностью реализующая старый сценарий автозаполнения 4 услуг через `/api/ai`.  
  - В новой UX‑схеме онбординга она **не вызывается ни из одного обработчика** (все кнопки переведены на онбординг).
- **Почему это важно для сопровождения**  
  - Читая код, легко решить, что автозаполнение всё ещё активно, хотя по факту — нет.  
  - Это увеличивает когнитивную нагрузку на разработчика и усложняет аудит поведения.
- **Предложенная правка (низкий приоритет)**  
  - Либо удалить `callServicesAi` и связанный код,  
  - либо обернуть в комментарий/`// LEGACY` с пояснением, что это старый флоу и не используется.  
  - Функционально на UX это не влияет, но сильно упрощает чтение кода.
- **Риск / побочный эффект**  
  - Нулевой для пользователя, но затрагивает «археологию» кода — только делать, если уверены, что старый флоу больше не нужен.

---

### Быстрые победы (quick wins)

1. **UX при активном Telegram‑hint**  
   - Сделать клик по «Помощь AI» понятным, даже если онбординг заблокирован:  
     скролл к Telegram‑hint + краткая подсветка блока.  
   - Это сразу убирает ощущение «сломавшейся кнопки» и не меняет бизнес‑логику.

2. **Очистка debug‑шума**  
   - Удалить/ограничить `console.log` и build‑маркер `SERVICES_ONBOARDING_BUILD_MARKER` после того, как убедимся в попадании кода в bundle.  
   - Пользователи не увидят разницы в UI, но консоль и бандл станут чище и предсказуемей.

